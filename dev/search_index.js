var documenterSearchIndex = {"docs":
[{"location":"PrintLog/#Logging","page":"Logging","title":"Logging","text":"","category":"section"},{"location":"PrintLog/","page":"Logging","title":"Logging","text":"Modules = [OTRecod]\nPages   = [\"PrintLog.jl\"]","category":"page"},{"location":"plot_functions/#Plots","page":"Plots","title":"Plots","text":"","category":"section"},{"location":"plot_functions/","page":"Plots","title":"Plots","text":"Modules = [OTRecod]\nPages   = [\"plot_functions.jl\"]","category":"page"},{"location":"ot_joint/#Joint","page":"Joint","title":"Joint","text":"","category":"section"},{"location":"ot_joint/","page":"Joint","title":"Joint","text":"Modules = [OTRecod]\nPages   = [\"ot_joint.jl\"]","category":"page"},{"location":"ot_joint/#OTRecod.ot_joint","page":"Joint","title":"OTRecod.ot_joint","text":"ot_joint(inst)\not_joint(inst, maxrelax)\not_joint(inst, maxrelax, lambda_reg)\not_joint(inst, maxrelax, lambda_reg, percent_closest)\not_joint(inst, maxrelax, lambda_reg, percent_closest, norme)\not_joint(\n    inst,\n    maxrelax,\n    lambda_reg,\n    percent_closest,\n    norme,\n    aggregate_tol\n)\not_joint(\n    inst,\n    maxrelax,\n    lambda_reg,\n    percent_closest,\n    norme,\n    aggregate_tol,\n    full_disp\n)\not_joint(\n    inst,\n    maxrelax,\n    lambda_reg,\n    percent_closest,\n    norme,\n    aggregate_tol,\n    full_disp,\n    solver_disp\n)\n\n\nModel where we directly compute the distribution of the outcomes for each individual or for sets of indviduals that similar values of covariates\n\naggregate_tol: quantify how much individuals' covariates must be close for aggregation\nreg_norm: norm1, norm2 or entropy depending on the type of regularization\npercent_closest: percent of closest neighbors taken into consideration in regularization\nlambda_reg: coefficient measuring the importance of the regularization term\nfull_disp: if true, write the transported value of each individual; otherwise, juste write the number of missed transports\nsolver_disp: if false, do not display the outputs of the solver\n\n\n\n\n\n","category":"function"},{"location":"ot_group/#Group","page":"Group","title":"Group","text":"","category":"section"},{"location":"ot_group/","page":"Group","title":"Group","text":"Modules = [OTRecod]\nPages   = [\"ot_group.jl\"]","category":"page"},{"location":"ot_group/#OTRecod.individual_from_group_closest","page":"Group","title":"OTRecod.individual_from_group_closest","text":"individual_from_group_closest(\n    inst,\n    jointprobaA,\n    jointprobaB\n)\nindividual_from_group_closest(\n    inst,\n    jointprobaA,\n    jointprobaB,\n    percent_closest\n)\n\n\nSequentially assign the modality of the individuals to that of the closest neighbor in the other base until the joint probability values are met\n\n\n\n\n\n","category":"function"},{"location":"ot_group/#OTRecod.individual_from_group_optimal","page":"Group","title":"OTRecod.individual_from_group_optimal","text":"individual_from_group_optimal(\n    inst,\n    jointprobaA,\n    jointprobaB\n)\nindividual_from_group_optimal(\n    inst,\n    jointprobaA,\n    jointprobaB,\n    percent_closest\n)\n\n\nSolve an optimization problem to get the individual transport that minimizes total distance while satisfying the joint probability computed by the model by group\n\n\n\n\n\n","category":"function"},{"location":"ot_group/#OTRecod.ot_group","page":"Group","title":"OTRecod.ot_group","text":"ot_group(inst)\not_group(inst, percent_closest)\not_group(inst, percent_closest, maxrelax)\not_group(inst, percent_closest, maxrelax, indiv_method)\not_group(\n    inst,\n    percent_closest,\n    maxrelax,\n    indiv_method,\n    full_disp\n)\not_group(\n    inst,\n    percent_closest,\n    maxrelax,\n    indiv_method,\n    full_disp,\n    solver_disp\n)\n\n\nModel of group transport\n\npercent_closest: percent of closest neighbors taken in the computation of the costs\nmaxrelax: maximum percentage of deviation from expected probability masses\nindiv_method: specifies the method used to get individual transport from group joint probabilities\nfull_disp: if true, write the transported value of each individual;     otherwise, juste write the number of missed transports\nsolver_disp: if false, do not display the outputs of the solver\n\n\n\n\n\n","category":"function"},{"location":"#OTRecod.jl","page":"Documentation","title":"OTRecod.jl","text":"","category":"section"},{"location":"#Data-recoding","page":"Documentation","title":"Data recoding","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"When databases are constructed from heterogeneous sources, it is not unusual that different encodings are used for the same outcome. In such case, it is necessary to recode the outcome variable before merging two databases. The method proposed for the recoding is an application of optimal transportation where we search for a bijective mapping between the distributions of such variable in two databases. In this article, we build upon the work by Garés et al., where they transport the distributions of categorical outcomes assuming that they are distributed equally in the two databases. Here, we extend the scope of the model to treat all the situations where the covariates explain the outcomes similarly in the two databases. In particular, we do not require that the outcomes be distributed equally. For this, we propose a model where joint distributions of outcomes and covariates are transported. We also propose to enrich the model by relaxing the constraints on marginal distributions and adding an L1 regularization term. The performances of the models are evaluated in a simulation study, and they are applied to a real dataset. ","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"Valérie Garès & Jérémy Omer (2022) Regularized Optimal Transport of Covariates and Outcomes in Data Recoding, Journal of the American Statistical Association, 117:537, 320-333, DOI: 10.1080/01621459.2020.1775615","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"pdf","category":"page"},{"location":"#Installation","page":"Documentation","title":"Installation","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"In a Julia session switch to pkg> mode to add NPSMC:","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"julia>] # switch to pkg> mode\npkg> add https://github.com/otrecoding/OTRecod.jl","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"Alternatively, you can achieve the above using the Pkg API:","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"julia> using Pkg\njulia> pkg\"add https://github.com/otrecoding/OTRecod.jl\"","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"When finished, make sure that you're back to the Julian prompt (julia>) and bring OTRecod into scope:","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"julia> using OTRecod","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"You can test the package with","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"julia>] # switch to pkg> mode\npkg> test OTRecod","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"To run an example from a dataset","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"run_directory","category":"page"},{"location":"#OTRecod.run_directory","page":"Documentation","title":"OTRecod.run_directory","text":"run_directory(path, method)\nrun_directory(path, method, outname)\nrun_directory(path, method, outname, maxrelax)\nrun_directory(path, method, outname, maxrelax, lambda_reg)\nrun_directory(\n    path,\n    method,\n    outname,\n    maxrelax,\n    lambda_reg,\n    nbfiles\n)\nrun_directory(\n    path,\n    method,\n    outname,\n    maxrelax,\n    lambda_reg,\n    nbfiles,\n    norme\n)\nrun_directory(\n    path,\n    method,\n    outname,\n    maxrelax,\n    lambda_reg,\n    nbfiles,\n    norme,\n    percent_closest\n)\nrun_directory(\n    path,\n    method,\n    outname,\n    maxrelax,\n    lambda_reg,\n    nbfiles,\n    norme,\n    percent_closest,\n    observed\n)\n\n\nRun one given method on a given number of data files of a given directory  The data files must be the only files with extension \".txt\" in the directory\n\npath   : name of the directory\nmethod : :group or :joint\nmaxrelax: maximum percentage of deviation from expected probability masses\nlambda_reg: coefficient measuring the importance of the regularization term\nnbfiles: number of files considered, 0 if all the data files are tested\nnorme  : 0, 1 or 2, norm used for distances in the space of covariates\npercent_closest: percent of closest neighbors taken in the computation of the costs (both distance and regularization related)\nobserved: if nonempty, list of indices of the observed covariates; this allows to exclude some latent variables.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Documentation","title":"Documentation","text":"julia> using OTRecod","category":"page"},{"location":"#Instance","page":"Documentation","title":"Instance","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"Instance","category":"page"},{"location":"#OTRecod.Instance","page":"Documentation","title":"OTRecod.Instance","text":"struct Instance\n\nDefinition and initialization of an Instance structure\n\ndatafile : file name\nnorme    : ( 1 : Cityblock, 2 : Euclidean, 3 : Hamming )\nindXA    : indexes of subjects of A with given X value\nindXB    : indexes of subjects of B with given X value\n\n\n\n\n\n","category":"type"},{"location":"#Solution","page":"Documentation","title":"Solution","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"Solution","category":"page"},{"location":"#OTRecod.Solution","page":"Documentation","title":"OTRecod.Solution","text":"mutable struct Solution\n\ntsolve       : solution time\njointYZA     : joint distribution of Y and Z in A\njointYZB     : joint distribution of Y and Z in B\nestimatorZA  : estimator of probability of Z for individuals in base A\nestimatorYB  : estimator of probability of Y for individuals in base B\n\n\n\n\n\n","category":"type"},{"location":"utils/#Helper-functions","page":"Utilities","title":"Helper functions","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Modules = [OTRecod]\nPages   = [\"disp_inst_inf.jl\", \"distrib_error.jl\", \"pred_error.jl\",\n           \"aggregate_per_covar_mixed.jl\", \"empirical_distribution.jl\",\n           \"average_distance_closest.jl\", \"empirical_estimator.jl\",\t\n           \"simulate.jl\", \"bound_prediction_error.jl\",\n           \"compute_average_error_bound.jl\"]","category":"page"},{"location":"utils/#OTRecod.disp_inst_info-Tuple{Instance}","page":"Utilities","title":"OTRecod.disp_inst_info","text":"disp_inst_info(inst)\n\n\nDisplay information about the distance between the modalities\n\n\n\n\n\n","category":"method"},{"location":"utils/#OTRecod.compute_distrib_error!-Tuple{Solution, Instance, Any, Any}","page":"Utilities","title":"OTRecod.compute_distrib_error!","text":"compute_distrib_error!(sol, inst, empiricalZA, empiricalYB)\n\n\nCompute errors in the conditional distributions of a solution\n\n\n\n\n\n","category":"method"},{"location":"utils/#OTRecod.compute_distrib_error_3covar-Tuple{Solution, Instance, Any, Any}","page":"Utilities","title":"OTRecod.compute_distrib_error_3covar","text":"compute_distrib_error_3covar(\n    sol,\n    inst,\n    empiricalZA,\n    empiricalYB\n)\n\n\n\n\n\n\n","category":"method"},{"location":"utils/#OTRecod.compute_pred_error!","page":"Utilities","title":"OTRecod.compute_pred_error!","text":"compute_pred_error!(sol, inst)\ncompute_pred_error!(sol, inst, proba_disp)\ncompute_pred_error!(sol, inst, proba_disp, mis_disp)\ncompute_pred_error!(\n    sol,\n    inst,\n    proba_disp,\n    mis_disp,\n    full_disp\n)\n\n\nCompute prediction errors in a solution\n\n\n\n\n\n","category":"function"},{"location":"utils/#OTRecod.aggregate_per_covar_mixed","page":"Utilities","title":"OTRecod.aggregate_per_covar_mixed","text":"aggregate_per_covar_mixed(inst)\naggregate_per_covar_mixed(inst, norme)\naggregate_per_covar_mixed(inst, norme, aggregate_tol)\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#OTRecod.empirical_distribution","page":"Utilities","title":"OTRecod.empirical_distribution","text":"empirical_distribution(inst)\nempirical_distribution(inst, norme)\nempirical_distribution(inst, norme, aggregate_tol)\n\n\nReturn the empirical cardinality of the joint occurrences of (C=x,Y=mA,Z=mB) in both bases\n\n\n\n\n\n","category":"function"},{"location":"utils/#OTRecod.average_distance_to_closest-Tuple{Instance, Float64}","page":"Utilities","title":"OTRecod.average_distance_to_closest","text":"average_distance_to_closest(inst, percent_closest)\n\n\nCompute the cost between pairs of outcomes as the average distance between covariations of individuals with these outcomes, but considering only the percent closest neighbors\n\n\n\n\n\n","category":"method"},{"location":"utils/#OTRecod.avg_distance_closest-Tuple{Instance, OTRecod.DataBase, OTRecod.DataBase, OTRecod.DataBase, Int64, Int64, Float64}","page":"Utilities","title":"OTRecod.avg_distance_closest","text":"avg_distance_closest(\n    inst,\n    base1,\n    base2,\n    outcome,\n    m1,\n    m2,\n    percent_closest\n)\n\n\nCompute the average distance between individuals of base1 with modality m1 for outcome and individuals of base2 with modality m2 for outcome\n\nConsider only the percent_closest individuals in the computation of the distance\n\n\n\n\n\n","category":"method"},{"location":"utils/#OTRecod.empirical_estimator","page":"Utilities","title":"OTRecod.empirical_estimator","text":"empirical_estimator(path)\nempirical_estimator(path, observed)\n\n\nGet an empirical estimator of the distribution of Z conditional to Y and X on base A and reciprocally on base B obtain with a specific type of data sets\n\npath: path of the directory containing the data set\nobserved: if nonempty, list of indices of the observed covariates; this allows to exclude some latent variables.\n\n\n\n\n\n","category":"function"},{"location":"utils/#OTRecod.simulate","page":"Utilities","title":"OTRecod.simulate","text":"simulate()\nsimulate(R2)\nsimulate(R2, muA)\nsimulate(R2, muA, muB)\nsimulate(R2, muA, muB, alphaA)\nsimulate(R2, muA, muB, alphaA, alphaB)\nsimulate(R2, muA, muB, alphaA, alphaB, n)\nsimulate(R2, muA, muB, alphaA, alphaB, n, q1)\nsimulate(R2, muA, muB, alphaA, alphaB, n, q1, q2)\nsimulate(R2, muA, muB, alphaA, alphaB, n, q1, q2, q3)\n\n\nSimulate one dataset with three covariates described by their mean in each database (muA and muB) and the quantiles used for discretization (q1,q2,q3) The dependency of outcomes on covariates is linear and given by the weights alpha1, alpha2 and by the R2 coefficient The instance contains n individuals in each base \n\n\n\n\n\n","category":"function"},{"location":"utils/#OTRecod.bound_prediction_error","page":"Utilities","title":"OTRecod.bound_prediction_error","text":"bound_prediction_error(inst)\nbound_prediction_error(inst, norme)\nbound_prediction_error(inst, norme, aggregate_tol)\n\n\nCompute a bound on the average prediction error in each base. The bound is computed as the expected prediction error assuming that the distribution of Z in base A (and that of Y in base B) is known, and the prediction done with the value that maximizes the probability\n\n\n\n\n\n","category":"function"},{"location":"utils/#OTRecod.compute_average_error_bound","page":"Utilities","title":"OTRecod.compute_average_error_bound","text":"compute_average_error_bound(path)\ncompute_average_error_bound(path, norme)\n\n\nCompute a lower bound on the best average prediction error that one can obtain with a specific type of data sets path: path of the directory containing the data set\n\n\n\n\n\n","category":"function"}]
}
